# 《UNIX环境高级编程》

第1章 UNIX基础知识
1.1 引言
1.2 UNIX体系结构
1.3 登录
```
    shell
        是一个命令行解释器
```

1.4 文件和目录
```
    根目录
        /
    文件属性的信息
        函数
            stat
            fstat   
    目录
        当前目录
            .
        上一层目录
            .. 
```

1.5 输入和输出
```
    文件描述符
        内核用以标识一个特定进程正在访问的文件    
    标准输入、输出、错误
        每当运行一个新程序时shell都为其打开3个文件描述符
        可重定向
            ls的3个描述符默认定向到终端    
    不带缓冲的I/O
        open\read\write\lseek\close
    标准 I/O
        printf
```

1.6 程序和进程
```
    内核使用exec函数将程序读入内存并执行
    进程 process ID
        getpid
    进程控制
        fork
        exec
        waitpid
    线程 thread ID
    特殊字符
        控制字符
            文件结束符
                ^D
                Ctrl+D
```


1.7 出错处理
```
    系统函数出错时返回一个负值
        errno
            保留上次判定的值
            不被其他函数设置为0
```


1.8 用户标识
```
    用户ID
        根用户 超级用户
            ID 0
        getuid
    组ID
        将若干用户集合到项目或部门中
        /etc/group
        getgid
```


1.9 信号
```
    通知进程发生了某种情况
        中断键
            Ctrl+C
        退出键
            Ctrl+\
        Kill( )
```

1.10 时间值
```
    日历时间
        19700101 00:00:00
    进程时间 CPU时间
        用以度量进程使用的CPU资源
        进程时间以时钟滴答计算
        每秒钟曾经取 50/60/100 个滴答
    CPU时间
        用户CPU时间+系统CPU时间
    度量进程执行时间时有3个进程时间值
        时钟时间
            进程运行的时间总量
        用户CPU时间
            执行用户指令所用的时间量
        系统CPU时间
            在内核内执行所花费时间量
```


1.11 系统调用和库函数
```
    系统调用 system call
        直接进入内核的多种服务入口点
        提供最小接口

    库函数
        用户层级
        提供比较复杂的功能
```
第3章 文件I/O
3.1 引言
3.2 文件描述符
```
    文件描述符
        内核用以标识一个特定进程正在访问的文件    
    标准输入
        文件描述符 0   
    标准输出
        文件描述符 1
    标准错误
        文件描述符 2
```
3.3 函数open和openat
3.4 函数creat
3.5 函数close
3.6 函数 lseek
```
    每个打开文件都有一个与其相关联的’当前文件偏移量‘
    用以度量从文件开始处计算的字节数
    读、写操作都从当前文件偏移量处开始
        并使偏移量增加所读写的字节数
```

3.7 函数read
3.8 函数write
3.9 I/O的效率
3.10 文件共享
```
    每个进程在进程表中都哟一个记录项
        记录项中包含一张打开文件描述符表
        每个文件描述符相关联的是
            文件描述符标志 close_on_exec
            指向一个文件表项的指针

    内核为所有打开文件维护一张文件表
        每个文件表项包含
            文件状态标志
            当前文件偏移量
            指向该文件 v节点 表项的指针

    每个打开文件或设备都有一个 v节点 结构
        v节点包含
            文件类型
            对此文件的各项操作函数的指针


    如果两个独立的进程各自打开同一个文件
        假设第一个进程在文件描述符3上打开该文件
        另一个进程在文件描述符4上打开该文件
            打开该文件的每个进程都得到一个文件表项
                因为每个进程都有它自己的对该文件的当前偏移量
                    而对于一个给定的文件只有一个v节点表项
``` 
3.11 原子操作
```
    原子操作（atomic operation）意为"不可被中断的一个或一系列操作" 
        i=1进行两次i++操作结果可能=2
                
        原因是有可能多个处理器同时从各自的缓存中读取变量i
    处理器使用总线锁
        使用处理器提供的一个LOCK＃信号
            当一个处理器在总线上输出此信号时
                其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存
```
3.12 函数dup和dup2
3.13 函数sync、fsync和fdatasync
```
延迟写 delayed write
内核通常先将数据复制到缓冲区，然后加入队列，晚些时候在写入磁盘
```
3.14 函数fcntl
3.15 函数ioctl
3.16 /dev/fd
3.17 小结
习题
第4章 文件和目录
4.1 引言
4.2 函数stat、fstat、fstatat和lstat
4.3 文件类型
```
    UNIX文件类型主要包含如下几种：
        1.普通文件（regular file）
        2.目录文件（directory file）
        3.块特殊文件（block special file）
            这种文件提供对设备（例如硬盘）带缓冲的访问
            每次访问以固定长度为单位进行
        4.字符特殊文件（character special file）
            这种文件提供对设备不带缓冲的访问
            每次访问长度可变
        5.FIFO文件
            命名管道（named pipe）
            用于进程间通信
        6.socket文件
            用于进程间的网络通信
            也可以在同一台机器上进行进程间通信
        7.符号链接文件（symbolic link）
            指向另外一个文件。
```


4.4 设置用户ID和设置组ID
```
实际用户 ID	我们实际上是谁
实际组 ID
有效用户 ID	用于文件访问权限检查
有效组 ID
附加组 ID
保存的设置用户 ID	由 exec 函数保存
保存的设置组 ID
```
4.5 文件访问权限
4.6 新文件和目录的所有权
4.7 函数access和faccessat
4.8 函数umask
4.9 函数chmod、fchmod和fchmodat
4.10 粘着位
4.11 函数chown、fchown、fchownat和lchown
4.12 文件长度
4.13 文件截断
4.14 文件系统
```
    UNIX 文件系统通过 i 节点来存储文件的信息
        节点数组
             i 节点
                是一个固定长度的记录项
                每个 i 节点都有一个链接计数
                    其值是指向该 i 节点的目录项数
                只有当链接计数减少至 0 时
                    才可删除该文件(即释放该文件所占用的数据块)    
        目录块
            i节点号
            文件名
        数据块
            用于存储文件的实际内容
                每个文件的 i 节点会记录该文件的内容所占用的数据块信息


    硬链接
        通过 i 节点编号来使多个目录项指向同一个文件
        限制
            硬链接要求链接和文件位于同一个文件系统中
                因为每个文件系统具有各自的 i 节点编号
            只有超级用户才能创建指向目录的硬链接
                避免在文件系统中存在循环
    符号链接 软链接
        该文件的实际内容(在数据块中)包含了该符号链接所指向的文件的名字
        用于将一个文件或整个目录结构移到文件系统中的另一个位置

```

4.15 函数link、linkat、unlink、unlinkat和remove
4.16 函数rename和renameat
4.17 符号链接
4.18 创建和读取符号链接
4.19 文件的时间
```
说明	字段
st_atime	文件数据的最后访问时间
st_mtime	文件数据的最后修改时间
st_ctime	i 节点状态的最后更改时间

    最后修改时间
        是文件内容最后一次被修改的时间
        ls -l file
    更改状态时间
        是该文件的 i 节点最后一次被修改的时间
            如更改文件访问权限、用户ID、链接数    

    最后访问时间
        ls -lu file
```


4.20 函数futimens、utimensat和utimes
4.21 函数mkdir、mkdirat和rmdir
4.22 读目录
4.23 函数chdir、fchdir和getcwd
4.24 设备特殊文件
4.25 文件访问权限位小结
4.26 小结
习题
第5章 标准I/O库
5.1 引言
5.2 流和FILE对象
5.3 标准输入、标准输出和标准错误
5.4 缓冲
```
    标准 I/O 流提供了缓冲是为了尽可能减少使用 read 和 write 系统调用的次数
        类型
            全缓冲
                在填满标准 I/O 缓冲区之后才进行实际 I/O操作
                对于驻留在磁盘上的文件通常是由标准 I/O 库实施全缓冲的 
            行缓冲
                当在输入和输出中遇到换行符时
                    标准 I/O库执行 I/O 操作
                当流涉及一个终端时(例如标准输入和标准输出),通常使用行缓冲 
            不带缓冲
                标准 I/O 库不对字符进行缓冲存储
                标准出错流 stderr 通常是不带缓冲的 
```

5.5 打开流
5.6 读和写流
```
    标准 I/O 库提供了三种不同类型的非格式化 I/O 来对流进行读、写操作
        1. 每次一个字符的 I/O:
            一次读或写一个字符
        2. 每次一行的 I/O:
            每次读或写一行,每行都以一个换行符终止
        3. 直接 I/O:
            每次读或写指定长度的数据
```

5.7 每次一行I/O
5.8 标准I/O的效率
5.9 二进制I/O
5.10 定位流
5.11 格式化I/O
5.12 实现细节
5.13 临时文件
5.14 内存流
5.15 标准I/O的替代软件
5.16 小结
习题
第6章 系统数据文件和信息
6.1 引言
6.2 口令文件
```
finger -p root
Login: root           			Name: root
Directory: /root                    	Shell: /bin/bash
On since Sun Mar 19 22:31 (EDT) on pts/0 from 192.168.11.128
   6 hours 8 minutes idle
On since Wed Mar 22 04:19 (EDT) on pts/2 from 192.168.11.128
   2 seconds idle
Last login Wed Mar 22 20:50 (EDT) on 
```

6.3 阴影口令
6.4 组文件
6.5 附属组ID
6.6 实现区别
6.7 其他数据文件
```
cat /etc/group
cat /etc/hosts
cat /etc/protocols
cat /etc/networks
cat /etc/shadow
cat /etc/services
```
6.8 登录账户记录
6.9 系统标识
6.10 时间和日期例程
6.11 小结
习题
第7章 进程环境
7.1 引言
7.2 main函数
7.3 进程终止
```
    进程的终止方式有 8 种
        正常终止
            1. 从 main 返回
            2. 调用 exit
            3. 调用_exit 或_Exit
            4. 最后一个线程从其启动例程返回
            5. 最后一个线程调用pthread_exit
        异常终止
            1. 调用 abort
            2. 接到一个信号并终止
            3. 最后一个线程对取消请求做出响应


    exit函数
        _exit 和_Exit 立即进入内核
        exit 则先执行一些清理处理
            调用执行各终止处理程序
            关闭所有标准 I/O 流等
                然后进入内核
    程序的启动与终止
```

7.4 命令行参数
7.5 环境表
```
    在每个进程启动时,都会接到一张环境表
        环境表是一个字符指针数组
            其中每个指针包含一个以 null 结束的 C 字符串的地址
```

 

7.6 C程序的存储空间布局
```
典型的存储空间安排

C程序一直由下面几部分组成： 

    正文段
        这是由CPU执行的机器指令部分
        正文段是可共享的
            所以即使是频繁执行的程序（如文本编辑器、C编译器和shell等）在存储器中也只需有一个副本
        正文段常常是只读的
            以防止程序由于意外而修改其自身的指令
    初始化数据段
        所有带有初始值的全局变量
        通常将此段称为数据段
        它包含了程序中需明确地赋初值的变量
            例如C程序中出现在任何函数之外的声明：int maxcount = 99
                使此变量带有其初值存放在初始化数据段中。
    非初始化数据段
        所有未带初始值的全局变量
        通常将此段称为bss段
            这一名称来源于一个早期的汇编运算符
            意思是“block started by symbol”（由符号开始的块）
                在程序开始执行之前
                    内核将此段中的数据初始化为0或空指针
                出现在任何函数外的C声明：long sum[1000]
                    使此变量存放在非初始化数据段中
    栈
        局部变量和形参
        自动变量以及每次函数调用时所需保存的信息都存放在此段中
        每次调用函数时
            其返回地址以及调用者的环境信息（例如某些机器寄存器的值）都存放在栈中
                然后最近被调用的函数在栈上为其自动变量和临时变量分配存储空间
            通过这种方式使用栈
                可以递归调用C函数
                    递归函数每次调用自身时
                        就使用一个新的栈帧
                            因此一个函数调用实例中的变量集不会影响另一个函数调用实例中的变量
    堆
        通常在堆中进行动态存储分配
            由于历史上形成的惯例堆位于非初始化数据段和栈之间。


size命令报告正文段、数据段和bss段的长度
size /usr/bin/cc /bin/sh
   text	  data	   bss	   dec	   hex	filename
 753831	  8504	 81856	844191	 ce19f	/usr/bin/cc
 903117	 35984	 22920	962021	 eade5	/bin/sh
```
7.7 共享库
```
    共享库使得可执行文件中不再需要包含共用的库例程
        而只需在所有进程都可引用的存储区中维护这种库例程的一个副本
    程序第一次执行或者第一次调用某个库函数时
        用动态链接方法将程序与共享库函数相链接
    共享库的另一个优点是可以用库函数的新版本代替老版本
        而无需对使用该库的程序重新链接
```
7.8 存储空间分配
7.9 环境变量
7.10 函数setjmp和longjmp
7.11 函数getrlimit和setrlimit
7.12 小结
习题
第8章 进程控制
```
    进程的控制三部曲
        fork 创建新进程
            在一个现有的进程中通过调用 fork 函数来创建一个新进程   
        exec 执行新程序
        exit 和 wait 处理终止和等待终止

    可中断状态：
        进程正在等待一个信号或者资源
    不可中断状态：
        不可被信号唤醒
        一般用于硬件初始化时
    暂停状态：
        当进程收到SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU信号后
            就会进入TASK_STOPPED状态
        可向其发送SIGCONT信号让进程转换到可运行状态 
    僵尸状态：
        当进程已经运行结束
            但其父进程还未查询其状态
```
 
8.1 引言
8.2 进程标识
```
    每个进程都有一个非负整型表示的唯一进程 ID
        进程 ID可以被重用
        当一个进程终止时
            其进程 ID 就可以用于另一个新的进程
            不过 UNIX 通过采用延迟重用算法
            使得赋予新进程的 ID 不同于最近终止的进程所使用的 ID
            防止将新进程误认为是使用同一个 ID的已经终止的前进程
    UNIX 系统通常有一些特殊的进程
        （1）交换进程 swapper：
            交换进程是 UNIX 系统的调度进程
            其进程 ID 为 0
                该进程是内核的一部分,它并不执行任何磁盘上的程序
            init 进程 init 进程的进程 ID 为 1
                它在自举过程结束时由内核调用
        （2）init进程：
            通常读取与系统有关的初始化文件
                /etc/rc* 文件
                /etc/inittab文件
                /etc/init.d 中的文件
                    并将系统引导到一个状态
            init 进程是一个以超级用户特权执行的用户进程
            它不会终止
            所有孤儿进程的父进程
```

8.3 函数fork
由 fork 创建的新进程被称为子进程
```
    两次返回的唯一区别是:
        子进程返回值为 0
        父进程的返回值是新子进程的进程 ID
    fork 函数返回之后
        子进程和父进程都各自继续执行 fork 调用之后的指令
        子进程获得了父进程数据空间、堆和栈的副本
```



8.4 函数vfork
8.5 函数exit
```
    exit 函数的参数作为程序的退出状态(exit status)
    在进程终止时
        内核会将程序的退出状态作为进程的终止状态(termination status)
```


8.6 函数wait和waitpid
```
    在进程异常终止的时候
        内核会产生一个指示其异常终止原因的终止状态
    无论进程是正常终止还是异常终止
        该终止进程的父进程都可以通过 wait 或 waitpid 函数获取其终止状态
```



8.7 函数waitid
8.8 函数wait3和wait4
8.9 竞争条件
8.10 函数exec
exec执行新程序 
```
    用 fork 函数创建子进程后
        子进程往往要调用一种 exec 函数以执行另一个程序
    当进程调用一种 exec 函数时
        该进程执行的程序完全替换为新程序
            而新程序则从其 main 函数开始执行
    调用 exec 并没有创建新进程
        所以进程 ID 没有改变
            exec只是用一个新的程序替换了当前进程的正文、数据、堆和栈段
    7个exec函数之间的关系
        fexecve    
```
 

8.11 更改用户ID和更改组ID
8.12 解释器文件
```
    interpreter file 文本文件
    以#！pathname开头
    exec执行文件中pathname所指定的文件
```

8.13 函数system
```
    system 函数的返回值有点复杂,
        1. 如果 cmdstring 是空指针
            则仅当命令处理程序处理程序可用时
                返回非 0 值
            这一特征可用于确定一个操作系统是否支持 system 函数
            UNIX 系统总是支持 system 函数的
        2. 如果 fork 失败或者 waitpid 返回除 EINTR 之外的出错
            则 system返回 -1
            而且 errno 中设置错误类型值
        3. 如果 exec 失败
            表示不能执行 shell
            则其返回值相当于 shell 执行了 exit(127) 后的终止状态
        4. 如果所有三个函数 (fork、exec 和 waitpid) 都执行成功
            则 system的返回值是 shell 执行命令参数 cmdstring 后的终止状态
    system 函数创建进程相对于 fork 与 exec 函数组合
        优点是:
            system函数进行了所需的各种出错处理,以及各种信号处理
        致命弱点:
            在设置用户 ID 程序中使用 system 函数会存在安全性漏洞
```

8.14 进程会计
```
    大多数UNIX系统提供了一个选项以进行进程会计（process accounting）处理
    启用该选项后
        每当进程结束时内核就写一个会计记录
            典型的会计记录包含总量较小的二进制数据
            一般包括命令名、所使用的CPU时间总量、用户ID和组ID、启动时间等

    函数（acct）用于启用和禁用进程会计
        唯一使用这一函数的命令是accton（8）命令
        超级用户（系统管理员）执行一个带路径名参数（如：/var/account/pacct）的accton命令启动会计处理
        会计记录写到由带路径名参数指定的文件中
        在Linux中，该文件是/var/account/pacct
        执行不带任何参数的accton命令可停止会计处理

     会计记录所需的各种数据（如CPU时间、传输的字符数）都由内核保存在进程表中.
        并在一个新进程被创建时置初值（例如调用fork之后在子进程中）
        每次进程终止时都会编写一条会计记录 

    会计记录对应于进程而不是程序
        在fork之后
            内核为子进程初始化一个记录
                而不是在一个新程序被执行时做这项工作 
        虽然exec并不创建一个新的会计记录
            但改变了相应记录中的命令名
                并且AFORK标志会被清除 
        这意味着如果一个进程顺序执行了三个程序（A exec B，然后B exec C，最后C exit）
            但只会写一条会计记录 
        该记录中的命令名对应于程序C
            但CPU时间是程序A、B、C之和 
```


8.15 用户标识
```
    任一进程都可以得到其实际和有效用户ID及组ID
        但是有时希望找到运行该程序的用户登录名
            我们可以调用getpwuid（getuid（））
    但是如果一个用户有多个登录名
        这些登录名又对应着同一个用户ID
            那么又将如何呢
                一个人在口令文件中可以有多个登录项，它们的用户ID相同，但登录shell则不同
    系统通常记录用户登录时使用的名字
    用getlogin函数可以获取此登录名
    如果调用此函数的进程没有连接到用户登录时所用的终端
        则本函数会失败
            通常称这些进程为守护进程（daemon）
```


8.16 进程调度
```
    Linux进程调度的目标
        1.高效性：
            高效意味着在相同的时间下要完成更多的任务
            调度程序会被频繁的执行
                所以调度程序要尽可能的高效
        2.加强交互性能:在系统相当的负载下
            也要保证系统的响应时间 
        3.保证公平和避免饥渴 
        4.SMP调度：
            调度程序必须支持多处理系统 
        5.软实时调度：
            系统必须有效的调用实时进程
                但不保证一定满足其要求 

    Linux进程优先级
        进程提供了两种优先级
            普通的进程优先级
                适用SCHED_NORMAL调度策略    
            实时优先级
                可选SCHED_FIFO或SCHED_RR调度策略
            任何时候实时进程的优先级都高于普通进程
                实时进程只会被更高级的实时进程抢占
                    同级实时进程之间是按照FIFO（一次机会做完）或者RR（多次轮转）规则调度的 


    实时进程
        只有静态优先级
            因为内核不会再根据休眠等因素对其静态优先级做调整
            其范围在0~MAX_RT_PRIO-1间
            默认MAX_RT_PRIO配置为100 
            默认的实时优先级范围是0~99
            而nice值，影响的是优先级在MAX_RT_PRIO~MAX_RT_PRIO+40范围内的进程 


    不同与普通进程，系统调度时，实时优先级高的进程总是先于优先级低的进程执行。知道实时优先级高的实时进程无法执行。实时进程总是被认为处于活动状态。如果有数个 优先级相同的实时进程，那么系统就会按照进程出现在队列上的顺序选择进程。假设当前CPU运行的实时进程A的优先级为a，而此时有个优先级为b的实时进程B进入可运行状态，那么只要b<a，系统将中断A的执行，而优先执行B，直到B无法执行（无论A，B为何种实时进程）。
    不同调度策略的实时进程只有在相同优先级时才有可比性：

    1. 对于FIFO的进程，意味着只有当前进程执行完毕才会轮到其他进程执行。由此可见相当霸道。
    2. 对于RR的进程。一旦时间片消耗完毕，则会将该进程置于队列的末尾，然后运行其他相同优先级的进程，如果没有其他相同优先级的进程，则该进程会继续执行。
    总而言之，对于实时进程，高优先级的进程就是大爷。它执行到没法执行了，才轮到低优先级的进程执行。等级制度相当森严啊。
```


8.17 进程时间
8.18 小结
习题
第9章 进程关系
9.1 引言
9.2 终端登录
1、BSD终端登录
```
    系统管理员创建通常名为/etc/ttys的文件
        其中每个终端设备都有一行
            每一行说明设备名和传递给getty程序的参数
            例如，参数之一说明了终端的波特率等。
        当系统自举时
            内核创建ID为1的进程
                也就是init进程
                init进程使系统进入多用户状态
        init进程读文件/etc/ttys
            对每一个允许登录的终端设备
                init调用一次fork
                    它所生成的子进程则执行（exec）getty程序


        getty为终端设备调用open函数
            以读、写方式将终端打开
            如果设备是调制解调器
                则open可能会在设备驱动程序中滞留
                    直到用户拨号调制解调器
                        并且呼叫被应答
            一旦设备被打开
                则文件描述符0、1、2就被设置到该设备
                    然后getty输出“login：”之类的信息
                        并等待用户键入用户名
            如果终端支持多种速度
                则getty可以测试特殊字符以便适当地更改终端速度（波特率）


        当用户键入了用户名后
            getty的工作就完成了
                然后它以类似于下面的方式调用login程序：
                    execle("/bin/login", "login", "-p", username, (char *)0, envp);
            在gettytab文件中可能会有一些选项使其调用其他程序
                但系统默认的是login程序
        init以一个空环境调用getty
            getty以终端名
                例如TERM=foo
                    其中终端foo的类型取自gettytab文件
            和在gettytab中说明的环境字符串为login创建一个环境（envp参数）
                -p标志通知login保留传给它的环境
                    也可将其他环境字符串加到该环境中
                        但是不要替换它 


        login能执行多项工作
            因为它得到了用户名
                所以能调用getpwnam取得相应用户的口令文件登录项
                    然后调用getpass（3）以显示提示“Password：”
            接着读用户键入的口令（自然，禁止回送用户键入的口令）
                它调用crypt（3）将用户键入的口令加密
                    并与该用户在阴影口令文件中登录项的pw_passwd字段相比较
            如果用户几次键入的口令都无效
                则login以参数1调用exit表示登录过程失败
                    父进程（init）了解到子进程的终止情况后
                        将再次调用fork
                            其后接着执行getty
                                将对此终端重复上述过程
            如果用户正确登录
                login将执行如下工作：
                    将当前工作目录更改为该用户的起始目录（chdir）
                        调用chown改变该终端的所有权
                            使登录用户成为它的所有者
                        将对该终端设备的访问权限改变成用户读和写 
                        调用setgid及initgroups设置进程的组ID 


        用login所得到的所有信息初始化环境：
            起始目录（HOME）
            shell（SHELL）
            用户名（USER和LOGNAME）
            以及一个系统默认路径（PATH） 
            login进程改变为登录用户的用户ID（setuid）并调用该用户的登录shell
            login调用exec将其自身替换为登录用户的登录shell 
                execl("/bin/sh", "-sh", (char *)0);

        到此为止登录用户的登录shell开始运行
            其父进程ID是init进程ID（进程ID 1）
                所以此登录shell终止时
                    init会得到通知（接到SIGCHLD信号）
                        它会对该终端重复全部上述过程
                            将登录shell的文件描述符0、1和2设置为终端设备


        登录shell读取其启动文件
            Bourne shell和Korn shell是
                profile
            GNU Bourne-again shell是
                .bash_profile
                .bash_login
                .profile
            C shell是
                .cshrc
                .login
            这些启动文件通常会改变某些环境变量
                加上很多环境变量
            当执行完启动文件后
                用户最后得到shell提示符
                    并能键入命令


        现代UNIX系统已发展到支持多个身份验证过程
            例如FreeBSD、Linux、Mac OS X以及Solaris都支持被称为
                PAM（Pluggable Authentication Module，可插入式身份验证模块）
                    的更加灵活的方案
                    PAM允许管理员配置使用何种身份验证方法来访问那些使用PAM库编写的服务 


        如果应用程序需验证一用户是否具有适当的权限去执行某个服务
            那么我们可以将身份验证机制编写到应用中
                或者使用PAM库来得到等价的功能
        使用PAM的优点是
            管理员可以基于本地策略、针对不同任务配置不同的验证用户身份的方法 
```

2、Linux终端登录
```
    Linux的终端登录过程非常类似于BSD
    在Linux中
        /etc/inittab包含配置信息
            它说明了init应当为之启动getty进程的各终端设备
                这类似于系统V的方式
                依赖于所使用的getty的版本
            终端的各种特性要么在命令行上说明
                要么在文件/etc/gettyefs中说明 
```


9.3 网络登录
```
    通过串行终端登录至系统和经由网络登录至系统两者之间的主要（物理上的）区别是：
        网络登录
            终端和计算机之间的连接不是点对点连接
            login只是一种可用的服务
                这与其他网络服务（例如FTP或SMTP）的性质相同
            所有登录都经由内核的网络接口驱动程序（如以太网驱动程序）
                事先并不知道将会有多少这样的登录
            我们不是使一个进程等待每个可能的登录
                而是必须等待一个网络连接请求的到达
        终端登录
            init知道哪些终端设备可用来进行登录
                并为每个设备生成一个getty进程



        为使同一软件即能处理终端login又能处理网络login
            系统使用了一种称为伪终端（pseudo terminal）的软件驱动程序
                它仿真串行终端的运行行为
                    并将终端操作映射为网络操作，反之亦然
```

1、BSD网络登录
```
    在BSD中有一个称为inetd的进程
        因特网超级服务器
        它等待大多数网络连接
    作为系统启动的一部分
        init调用一个shell
            使其执行shell脚本/etc/rc
                由此shell脚本启动一个守护进程inetd
        一旦此shell脚本终止
            inetd的父进程就变成init
                inetd等待TCP/IP连接请求到达主机
                    而当一个连接请求到达时
                        它执行一次fork
                            然后生成的子进程执行适当的程序


        我们假定到达了一个针对TELNET服务进程的TCP连接请求
            TLENET是使用TCP协议的远程登录应用程序
            在另一台主机上的用户或在同一台主机上的用户启动TELNET客户端进程
                由此启动登录过程：
                    telnet hostname
            该客户进程打开一个到hostname主机的TCP连接
                在hostname主机上启动的程序被称为TELNET服务进程
                然后客户进程和服务进程之间使用TELNET应用协议通过TCP连接交换数据
                    所发生的是启动客户进程的用户现在登录到了服务进程所在的主机 
            然后telnetd进程（TELNET服务进程）打开一个伪终端设备
                并用fork分成两个进程
                    父进程处理通信网络连接的通信
                    子进程则执行login程序
                        父、子进程通过伪终端相连接
                在调用exec之前
                    子进程使其文件描述符0、1、2与伪终端相连
                    如果登录正确
                        login就执行与终端登录中同样的步骤：
                            更改当前工作目录为起始目录
                                设置登录用户的组ID和用户ID
                                    以及登录用户的初始环境
                                        然后login调用exec将其自身替换为登录用户的登录shell
            需要理解的重点是：
                当通过终端或网络登录时
                    我们得到一个登录shell
                        其标准输入、输出和标准出错连接到一个终端设备或者伪终端设备上
                        这一登录shell是POSIX.1会话的开始
                            而此终端或伪终端则是会话的控制终端
```

2、Linux网络登录
```
    除了使用扩展的因特网服务守护进程xinetd替代inetd进程外
        Linux网络登录的其他方面与BSD相同
        xinetd进程对它所启动的各种服务的控制比inetd提供的更加精细
```


9.4 进程组
```
    每个进程除了有一个进程ID之外
        还属于一个进程组
            进程组会有一个进程组领导进程(process group leader)

                ps -o pid,pgid,ppid,comm | cat

                 PID  PGID  PPID  COMMAND
                17763 17763 17751 bash

                18534 18534 17763 ps
                18535 18534 17763 cat

           

        SID                                                 Session ID     会话ID

            PGID                        Process Group ID     进程所在的进程组的ID
                PPID              Parent process ID      进程的父进程ID
                    PID                     process ID       进程自身的ID
                        TGID Thread Group ID     线程组 ID
    进程组是一个或多个进程的集合
        通常它们与同一作业相关联
            可以接收来自同一终端的各种信号
            每个进程组有一个唯一的进程组ID
                领导进程的PID成为进程组的ID (process group ID, PGID)
                    以识别进程组
                进程组ID类似于进程ID——它是一个正整数，并可存放在pid_t数据类型中
                函数getpgrp返回调用进程的进程组ID


    竞争条件
        在大多数作业控制shell中
            在fork之后调用此函数
                使父进程设置其子进程的进程组ID
                并且使子进程设置其自己的进程组ID
                    这两个调用中有一个是冗余的
                如果不这样做的话
                    那么fork之后由于父、子进程运行先后次序的不确定
                        会造成在一段时间内子进程组成员身份的不确定
                            父、子进程中只运行了其中一个
                                取决于哪个进程首先执行    
                                    这就产生了竞争条件
```


9.5 会话
```
    会话（session）是一个或多个进程组的集合

        通常是由shell的管道线将几个进程变成一组的
            proc1 | proc2 & proc3 | proc4 | proc5
        SID(Session ID 会话ID)
```

9.6 控制终端
```
    会话和进程组有一些其他特性：
        一个会话可以有一个控制终端（controlling terminal）
            这通常是登录到其上的终端设备（在终端登录情况下）或伪终端设备（在网络登录情况下）
        控制进程（controlling process）
            建立与控制终端连接的会话首进程
        一个会话中的几个进程组可被分成一个前台进程组（foreground process group）以及一个或几个后台进程组（background process group）
        如果一个会话有一个控制终端
            则它有一个前台进程组
                会话中的其他进程组则为后台进程组
        无论何时键入终端的中断键（常常是DELETE或Ctrl+C）
            就会将中断信号发送给前台进程组的所有进程。
        无论何时键入终端的退出键（常常是Ctrl+\）
            就会将退出信号发送给前台进程组中的所有进程。
        如果终端接口检测到调制解调器（或网络）已经断开连接
            则将挂断信号发送给控制进程--会话首进程

  

        有时不管标准输入、标准输出是否被重定向
            程序都要与控制终端交换
                保证程序能读写控制终端的方法是打开文件/dev/tty
            在内核中此特殊文件是控制终端的同义语
                如果程序没有控制终端
                    则打开此设备将失败
```

9.7 函数tcgetpgrp、tcsetpgrp和tcgetsid
9.8 作业控制
```
    它允许在一个终端上启动多个作业（进程组）
        它控制哪一个作业可以访问该终端
            以及哪些作业在后台运行
        作业控制要求下面三种形式的支持：
            （1）支持作业控制的shell 
            （2）内核中的终端驱动程序必须支持作业控制 
            （3）内核必须提供对某些作业控制信号的支持 
        从shell使用作业控制功能角度讲
            用户可以在前台或后台启动一个作业
                一个作业只是几个进程的集合
                    通常是一个进程的管道线


    在前台启动了只有一个进程组成的一个作业
        vi main.c
    在后台启动了两个作业
        pr *.c | lpr &
        make all &
        这两个后台作业调用的所有进程都在后台运行
        当启动一个后台作业时
            shell赋予它一个作业标识
                并打印一个或几个进程ID
    中断字符
        DELETE或Ctrl+C
        产生SIGINT
    退出字符
        trl+\
        产生SIGQUIT
    挂起字符
        Ctrl+Z
        产生SIGTSTP
        使终端驱动程序将信号SIGTSTP送至前台进程组中的所有进程
            后台进程组作业则不受影响。
    终端驱动程序必须处理与作业控制有关的另一种情况
        我们可以有一个前台作业和若干个后台作业
        这些作业中哪一个接受我们在终端上键入的字符呢？
            只有前台作业接收终端输入
            如果后台作业试图读终端
                那么这并不是一个错误
                    但是终端驱动程序将检测这种情况
                        并且向后台作业发送一个特定的信号SIGTTIN
                            该信号通常会暂时停止此后台作业
                                而shell则向有关用户发出这种情况的通知
                                    然后用户就可以用shell命令将此作业转为前台作业运行
                                        于是它就可以读终端
        如果后台作业输出到控制终端又将发生什么呢？
            这是一个我们可以允许或禁止的选项
                通常可以用stty（1）命令改变这一选项
                在用户禁止后台作业写到控制终端时
                如果后台作业输出到控制终端
                    终端驱动程序将该写操作标识为来自于后台进程
                        并向该作业发送SIGTTOU信号
    终端I/O和终端产生的信号总是从前台进程组连接到实际终端
        进程属于一个进程组
            而进程组属于一个会话
                会话可能有也可能没有控制终端
            如果它确实有一个控制终端
                则此终端设备知道其前台进程的进程组ID
                    这个值可以用tcsetpgrp函数在终端驱动程序中设置
                        前台进程组ID是终端的一个属性
                            而不是进程的属性
```


9.9 shell执行程序
```
    使用的shell不同
        创建各个进程的顺序也可能不同
```


9.10 孤儿进程组
```
    一个其父进程已终止的进程称为孤儿进程（orphan process）
        这种进程由init进程“收养”
    整个进程组也可以成为“孤儿”         
        孤儿进程组（orphan process group）：
            该组中每个成员的父进程
                要么是该组中的一个成员
                要么不是该组所属会话的成员
        对孤儿进程组的另一种描述：
            一个进程组不是孤儿进程组的条件是
                该组中有一个进程
                    其父进程属于同一会话的另一个组中        
```
 
9.11 FreeBSD实现
9.12 小结
习题
第10章 信号
10.1 引言
10.2 信号概念
```
    信号是软中断
        它提供了一种处理异步事件的方法
    每个信号都有一个名字
        这些名字都以三个字符SIG开头
        在头文件<signal.h>中
            这些信号都被定义为正整数（信号编号）
        实际上实现将各信号定义在另一个头文件中
            但是该头文件又包括在<signal.h>中
            通常若应用程序和内核两者都需使用同一定义
                那么就将有关信息放置在内核头文件中
                    然后用户级头文件再包括该内核头文件
        不存在编号为0的信号
            kill函数对信号编号0有特殊的应用
            POSIX.1将此种信号编号值称为空信号


    产生信号的条件：
        当用户按某些终端键时
            引发终端产生的信号
        硬件异常产生信号
        进程调用kill函数可将信号发送给另一个进程或进程组
            自然对此有所限制：
                接收信号进程和发送信号进程的所有者必须相同
                发送信号进程的所有者必须是超级用户
        用户可用kill命令将信号发送给其他进程
        当检测到某种软件条件已经发生
            并应将其通知有关进程时也产生信号
                这里指的不是硬件产生的条件

 

    信号是异步事件的经典实例
        产生信号的事件对进程而言是随机出现的
        进程不能简单地测试一个变量（例如errno）来判别是否出现了一个信号
        而是必须告诉内核“在此信号出现时请执行下列操作：
            可以要求内核在某个信号出现时按照下列三种方式之一进行处理
                忽略此信号
                    大多数信号都可使用这种方法进行处理
                    但是有两种信号决不能被忽略：
                        SIGKILL
                        SIGSTOP
                    这两种信号不能被忽略的原因是：
                        它们向超级用户提供了使进程终止或停止的可靠方法。
                        另外如果忽略某些由硬件异常产生的信号（例如除以0）
                            则进程的运行行为是未定义的。
                捕捉信号
                    要通知内核在某种信号发生时调用一个用户函数
                        在用户函数中可执行用户希望对这种事件进行的处理
                            注意不能捕捉SIGKILL和SIGSTOP信号
                执行系统默认动作
                    注意针对大多数信号的系统默认动作是终止进程
```


10.3 函数signal
为指定的信号安装一个新的信号处理函数
```
程序启动

    当执行一个程序时
        所有信号的状态都是系统默认或忽略
        通常所有信号都被设置为它们的默认动作
            除非调用exec的进程忽略该信号
            exec函数将原先设置为要捕捉的信号都更改为它们的默认动作
                其他信号的状态则不变
                    对于一个进程原先要捕捉的信号
                当其执行一个新程序后
                    就自然不能再捕捉它了
                        因为信号捕捉函数的地址很可能在所执行的新程序文件中无意义
        一个具体的例子是一个交互式shell如何处理针对后台进程的中断和退出信号
            对于一个非作业控制shell
                当在后台执行一个进程时
                    cc main.c &
                    shell自动将后台进程中对中断和退出信号的处理方式设置为忽略
                    于是当按中断键时就不会影响到后台进程
                    如果没有执行这样的处理
                        那么当按中断键时
                            它不但会终止前台进程
                                还会终止所有后台进程

进程创建

    当一个进程调用fork时
        其子进程继承父进程的信号处理方式
        因为子进程在开始时复制了父进程的存储映像
            所以信号捕捉函数的地址在子进程中是有意义的
```




10.4 不可靠的信号
10.5 中断的系统调用
10.6 可重入函数
10.7 SIGCLD语义
10.8 可靠信号术语和语义
```
    当引发信号的事件发生时
        为进程产生一个信号（或向进程发送一个信号）
            事件可以是
                硬件异常
                软件条件
                终端产生的信号
                调用kill函数

        在产生了信号时
            内核通常在进程表中设置一个某种形式的标志
                当对信号采取了这种动作时，
                    向进程递送了一个信号
        信号是未决的（pending）
            在信号产生（generation）和递送（delivery）之间的时间间隔
        进程可以选用信号递送阻塞
            如果为进程产生了一个选择为阻塞的信号
                而且对该信号的动作是系统默认动作或捕捉该信号
                    则为该进程将此信号保持为未决状态
                        直到该进程（a）对此信号解除了阻塞
                        或者（b）将对此信号的动作更改为忽略
        内核在递送一个原来被阻塞（现在解除了阻塞）的信号给进程时（而不是在产生该信号时）
            才决定对它的处理方式
                于是进程在信号递送给它之前仍可改变对该信号的动作
                    进程调用sigpending函数来判定哪些信号是设置为阻塞并处于未决状态的


        每个进程都有一个信号屏蔽字（signal mask）
            它规定了当前要阻塞递送到该进程的信号集
            对于每种可能的信号
                该屏蔽字中都有一位与之对应
                对于某种信号
                    若其对应位已设置
                        则它当前是被阻塞的
                            进程可以调用sigprocmask来检测和更改其当前信号屏蔽字
```

10.9 函数kill和raise
10.10 函数alarm和pause
10.11 信号集
10.12 函数sigprocmask
10.13 函数sigpending
10.14 函数sigaction
10.15 函数sigsetjmp和siglongjmp
10.16 函数sigsuspend
10.17 函数abort
10.18 函数system
10.19 函数sleep、nanosleep和clock_nanosleep
10.20 函数sigqueue
10.21 作业控制信号
10.22 信号名和编号
10.23 小结
习题
第11章 线程
11.1 引言
11.2 线程概念
```
    典型的UNIX进程可以看成只有一个控制线程：
        一个进程在同一时刻只做一件事情
    有了多个控制线程（或简称为线程）以后
        在程序设计时可以把进程设计成在同一时刻能够做不止一件事
            每个线程处理各自独立的任务


    这种方法有很多好处：
        通过为每种事件类型的处理分配单独的线程
            能够简化处理异步事件的代码
                每个线程在进行事件处理时可以采用同步编程模式
                    同步编程模式要比异步编程模式简单得多
        多个进程必须使用操作系统提供的复杂机制才能实现实现内存和文件描述符的共享
            而多个线程自动地可以访问相同的存储地址空间和文件描述符
        有些问题可以通过将其分解从而改善整个程序的吞吐量
            在只有一个控制线程的情况下
                单个进程需要完成多个任务时
                    实际上需要把这些任务串行化
            有了多个控制线程
                相互独立的任务的处理就可以交叉进行
                    只需要为每个任务分配一个单独的线程
                        当然只有在处理过程互不依赖的情况下
                            两个任务的执行才可以穿插进行
        交互的程序同样可以通过使用多线程实现响应时间的改善
            多线程可以把程序中处理用户输入输出的部分与其他部分分开


    有些人把多线程的程序设计与多处理器系统联系起来
        但是即使程序运行在单处理器上
            也能得到多线程编程模型的好处
        处理器的数量并不影响程序结构
            所以不管处理器的个数是多少
                程序都可以通过使用线程得以简化
            即使多线程程序在串行化任务时不得不阻塞
                由于某些线程在阻塞的时候还有另外一些线程可以运行
                    所以多线程程序在单处理器上运行仍然能够改善响应时间和吞吐量


    线程包含了表示进程内执行环境必需的信息
        其中包括
            进程中标识线程的线程ID
            一组寄存器值
            栈
            调度优先级
            策略
            信号屏蔽字
            errno变量
            线程私有数据
                进程的所有信息对该进程的所有线程都是共享的
                    包括
                        可执行的程序文本
                        程序的全局内存
                        堆内存
                        栈
                        文件描述符

```

11.3 线程标识
```
    就像每个进程有一个进程ID一样
        每个线程也有一个线程ID
    进程ID在整个系统中是唯一的
        但线程ID不同
            线程ID只在它所属的进程环境中有效
```


11.4 线程创建
11.5 线程终止
11.6 线程同步
```
    当多个控制线程共享相同的内存时
        需要确保每个线程看到一致的数据视图
            如果每个线程使用的变量都是其他线程不会读取或修改的
                那么就不会存在一致性问题
            如果变量是只读的
                多个线程同时读取该变量也不会有一致性问题
            如果某个线程可以修改变量
                而其他线程也可以读取或修改这个变量的时候
                    就需要对这些线程进行同步
                        以确保它们在访问变量的存储内容时不会访问到无效的数值


    当一个线程修改变量时
        其他线程在读取这个变量的值时就可能会看到不一致的数据
            在变量修改时间多于一个存储器访问周期的处理器结构中
                当存储器读与存储器写这两个周期交叉时
                    这种潜在的不一致性就会出现
                    当然这种行为是与处理器结构相关的
                        但是可移植性程序并不能对使用何种处理器结果作出假设


    为了解决这个问题
        线程不得不使用锁
            在同一时间只允许一个线程访问该变量
                如果线程B希望读取变量
                    它首先要获取锁
                同样地当线程A更新变量时
                    也需要获取这把同样的锁
                        因而线程B在线程A释放锁以前不能读取变量
        当两个或多个线程试图在同一时间修改同一变量时
            也需要进行同步
            考虑变量递增操作的情况
                增量操作通常可分为三步：
                    （1）从内存单元读入寄存器。
                    （2）在寄存器中进行变量值的增加。
                    （3）把新的值写回内存单元。

```
11.6.1 互斥量
```
    可以通过使用pthread的互斥接口保护数据
        确保同一时间只有一个线程访问数据
        互斥量（mutex）从本质上说是一把锁
            在访问共享资源前对互斥量进行加锁
                在访问完成后释放互斥量上的锁
        对互斥量进行加锁以后
            任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁
            如果释放互斥锁时有多个线程阻塞
                所有在该互斥锁上的阻塞线程都会变成可运行状态
                    第一个变为运行状态的线程可以对互斥量加锁
                        其他线程将会看到互斥锁依然被锁住
                            只能回去再次等待它重新变为可用
                                在这种方式下
                                    每次只有一个线程可以向前执行


    在设计时需要规定所有的线程必须遵守相同的数据访问规则
        只有这样互斥机制才能正常工作
            操作系统并不会做数据访问的串行化
                如果允许其中的的某个线程在没有得到锁的情况下也可以访问共享资源
                    那么即使其他的线程在使用共享资源前都获取了锁
                        也还是会出现数据不一致的问题

```

11.6.2 避免死锁
```
    如果线程试图对同一个互斥量加锁两次
        那么它自身就会陷入死锁状态
        使用互斥量时
            还有其他更不明显的方式也能产生死锁
            例如程序中使用多个互斥量时
                如果允许一个线程一直占有第一个互斥量
                    并且在试图锁住第二个互斥量时处于阻塞状态
                        但是拥有第二个互斥量的线程也在试图锁住第一个互斥量
                            这时就会发生死锁
    死锁
        因为两个线程都在相互请求另一个线程拥有的资源
            所以这两个线程都无法向前运行
                于是就产生死锁


    可以通过小心地控制互斥量加锁的顺序来避免死锁的发生
        假设需要对两个互斥量A和B同时加锁
            如果所有线程总是在对互斥量B加锁之前锁住互斥量A
                那么使用这两个互斥量不会产生死锁（当然在其他资源上仍可能出现死锁）
            如果所有的线程总是在锁住互斥量A之前锁住互斥量B
                那么也不会发生死锁
        只有在一个线程试图以与另一个线程相反的顺序锁住互斥量时
            才可能出现死锁


    有时候应用程序的结果使得对互斥量加锁进行排序是很困难的
        如果涉及了太多的锁和数据结构
            可用的函数并不能把它转换成简单的层次
                那么就需要采用另外的方法
                    可以先释放占有的锁
                        然后过一段时间再试
        这种情况可以使用pthread_mutex_trylock接口避免死锁
            如果已经占有某些锁而且pthread_mutex_trylock接口返回成功
                那么就可以前进
            但是如果不能获取锁
                可以先释放已经占有的锁
                    做好清理工作
                        然后过一段时间重新尝试
```


11.6.3 函数pthread_mutex_timedlock
11.6.4 读写锁
```
    读写锁与互斥量类似
        不过读写锁允许更高的并行性
            互斥量要么是锁住状态要么是不加锁状态
                而且一次只有一个线程可以对其加锁


    读写锁可以有三种状态：
        读模式下 
        写模式下  
        不加锁状态 


    一次只有一个线程可以占有写模式的读写锁
        但是多个线程可以同时占有读模式的读写锁


    当读写锁是写加锁状态时
        在这个锁被解锁之前
            所有试图对这个锁加锁的线程都会被阻塞


    当读写锁在读加锁状态时
        所有试图以读模式对它进行加锁的线程都可以得到访问权
            但是如果线程希望以写模式对此锁进行加锁
                它必须阻塞直到所有的线程释放读锁
                    虽然读写锁的实现各不相同
                        但当读写锁处于读模式锁住状态时
                            如果有另外的线程试图以写模式加锁
                                读写锁通常会阻塞随后的读模式锁请求
                                    这样可以避免读模式锁长期占用
                                        而等待的写模式锁请求一直得不到满足


    读写锁非常适合于对数据结构读的次数远大于写的情况
        当读写锁在写模式下时
            它所保护的数据结构就可以被安全地修改
                因为当前只有一个线程可以在写模式下拥有这个锁
        当读写锁在读模式下时
            只要线程获取了读模式下的读写锁
                该锁所保护的数据结构可以被多个获得读模式锁的线程读取
    读写锁也叫做共享-独占锁
        当读写锁以读模式锁住时
            它是以共享模式锁住的
        当它以写模式锁住时
            它是以独占模式锁住的
    与互斥量一样
        读写锁在使用之前必须初始化
            在释放它们底层的内存前必须销毁
```


11.6.5 带有超时的读写锁
11.6.6 条件变量
11.6.7 自旋锁
11.6.8 屏障
11.7 小结
习题
第12章 线程控制
12.1 引言
12.2 线程限制
12.3 线程属性
12.4 同步属性
12.4.1 互斥量属性
12.4.2 读写锁属性
12.4.3 条件变量属性
12.4.4 屏障属性
12.5 重入
12.6 线程特定数据
```
    线程私有数据   （也称线程特定数据）
        是存储和查询与某个线程相关的数据的一种机制
        把这种数据称为线程私有数据或线程特定数据的原因是：
            希望每个线程可以独立地访问数据副本
                而不需要担心与其他线程的同步访问问题
    线程模型促进了进程中数据和属性的共享
        许多人在设计线程模型时会遇到各种麻烦
            但在这样的模型中，为什么还需要提出一些合适的用于阻止共享的接口呢？
                其中有两个原因：
                    有时候需要维护基于每个线程的数据
                    它提供了让基于进程的接口适应多线程环境的机制
```

12.7 取消选项
12.8 线程和信号
```
    每个线程都有自己的信号屏蔽字
        但是信号的处理是进程中所有线程共享的
            这意味着尽管单个线程可以阻止某些信号
                但当线程修改了与某个信号相关的处理行为以后
                    所有的线程都必须共享这个处理行为的改变
    进程中的信号是递送到单个线程的
        如果信号与硬件故障或计时器超时相关
            该信号就被发送到引起该事件的线程中去
                而其他的信号则被发送到任意一个线程
```

12.9 线程和fork
12.10 线程和I/O
12.11 小结
习题
第13章 守护进程
13.1 引言
```
    守护进程也称精灵进程（daemon）
        是生存期较长的一种进程
        它们常常在系统自举时启动
        仅在系统关闭时才终止
        因为它们没有控制终端
            所以说它们是在后台运行的
```

13.2 守护进程的特征
```
    ps -axj
        x
            显示没有控制终端的进程状态    
        j
            显示与作业有关信息
    内核进程
        父进程ID为0的各进程
        它们作为系统自举过程的一部分而启动
            init是此种进程的例外，它是内核在自举时启动的用户层命令
        内核进程是特殊的
            通常存在于系统的整个生命期中
                它们以超级用户特权运行
                无控制终端
                无命令行


    进程1通常是init
        它是一个系统守护进程
        负责启动个运行层次特定的系统服务
        这些服务通常是在它们自己拥有的守护进程的帮助下实现的


    keventd守护进程
        为在内核中运行计划执行的函数提供进程上下文
    kapmd守护进程
        对很多计算机系统中具有的高级电源管理提供支持
    kswapd守护进程也称为页面调出守护进程（pageout daemon）
        它通过将脏页面以低速写到磁盘上从而使这些页面在需要时仍可回收利用
            这种方式支持虚存子系统

    bdflush和kupdated将高速缓存中的数据冲洗到磁盘上
        bdflush守护进程
            当可用内存达到下限时
                将脏缓冲区从缓冲池（buffer cache）中冲洗到磁盘上
        kupdated守护进程
            每隔一定时间间隔
                将脏页面冲洗到磁盘上
                以便在系统失效时减少丢失的数据


    portmap端口映射守护进程
        提供将RPC（Remote Procedure Call，远程过程调用）程序号映射为网络端口号的服务
    syslogd守护进程提供将系统消息记入日志的服务


    xinetd(inetd)守护进程
        它侦听系统网络接口
            以便取得来自网络的对各种网络服务进程的请求
    nfsd、lockd和rpciod守护进程提供对网络文件系统（Network File System，NFS）的支持


    cron守护进程（crond）
        在指定的日期和时间执行指定的命令
        cupsd守护进程是打印假脱机进程
            它处理对系统提出的所有打印请求


    大多数守护进程都以超级用户（用户ID为0）特权运行
        没有一个守护进程具有控制终端
            其终端设置为问号（？）
            终端前台进程组ID设置为-1
            内核守护进程以无控制终端方式启动
        用户层守护进程缺少控制终端可能是守护进程调用了setsid的结果
            所有用户层守护进程都是进程组的组长进程以及会话的首进程
                而且是这些进程组和会话中的唯一进程
                    应当引起注意的是大多数守护进程的父进程是init进程

```
13.3 编程规则
13.4 出错记录
syslog设施的详细组织结构
```
    有三种方法产生日志消息：
        （1）内核例程可以调用log函数
            任何一个用户进程通过打开（open）然后读（read）/dev/klog设备就可以读取这些消息
        （2）大多数用户进程（守护进程）调用syslog（3）函数以产生日志消息
            这使消息发送至UNIX域数据报套接字/dev/log
        （3）在此主机上的一个用户进程
            或通过TCP/IP网络连接到此主机的其他主机上的一个用户进程可将日志消息发向UDP端口514
            注意syslog函数并不产生这些UDP数据报
                而是要求产生此日志消息的进程进行显示的网络编程
    关于UNIX域套接字以及UDP套接字的细节
        请参阅《UNIX网络编程》
    syslog守护进程读取三种格式的日志消息
        此守护进程在启动时读一个配置文件
            一般其文件名为/etc/syslog.conf

```



13.5 单实例守护进程
```
    为了正常运行某些守护进程实现为单实例的
        也就是在任一时刻只运行该守护进程的一个副本
        例如该守护进程可能需要排它地访问一个设备
            在cron守护进程情况下
                如果同时有多个实例运行
                    那么每个副本都可能试图开始某个预定的操作
                        于是造成该操作的重复执行
                            这很可能导致出错


    如果守护进程需要访问一设备
        而该设备驱动程序将阻止多次打开在/dev目录下的相应设备节点
            那么这就达到了任何时刻只运行守护进程一个副本的要求
                但是如果没有这种设备可供使用
                    那么我们就需要自行处理


    文件锁和记录锁机制是一种方法的基础
        该方法用来保证一个守护进程只有一个副本在运行
        如果每一个守护进程创建一个文件
            并且在整个文件上加上一把写锁
                那就只允许创建一把这样的写锁
                    所以在此之后如试图再创建一把这样的写锁就将失败
                        以此向后续守护进程副本指明已有一个副本正在运行


    文件锁和记录锁提供了一种方便的互斥机制
        如果守护进程在整个文件上得到一把写锁
            那么在该守护进程终止时
                这把写锁将被自动删除
                    这就简化了复原所需的处理
                        去除了对以前的守护进程实例需要进行清理的有关操作

```

13.6 守护进程的惯例
```
    在UNIX系统中守护进程遵循下列公共惯例：
        若守护进程使用锁文件
            那么该文件通常存放在/var/run目录中
            注意守护进程可能需要具有超级用户权限才能在此目录下创建文件
                锁文件的名字通常是name.pid
                其中name是该守护进程或服务的名字
                    例如cron守护进程锁文件的名字是/var/run/crond.pid
        若守护进程支持配置选项
            那么配置文件通常存放在/etc目录中
                配置文件的名字通常是name.conf
                其中name是该守护进程或服务的名字
                    例如syslogd守护进程的配置文件是/etc/syslog.conf
        守护进程可用命令行启动
            但通常它们是由系统初始化脚本之一（/etc/rc*或/etc/init.d/*）启动的
            如果在守护进程终止时
                应当自动地重新启动它
                    则我们可在/etc/inittab中为该守护进程包括_respawn记录项
                        这样init就将重启动该守护进程
        若一守护进程有一配置文件
            那么当该守护进程启动时
                它读该文件但在此之后一般就不会再查看它
                若一管理员更改了配置文件
                    那么该守护进程可能需要被停止然后再启动
                        以使配置文件的更改生效
            为避免此种麻烦某些守护进程将捕捉SIGHUP信号
                当它们接收到该信号时重读配置文件
                    因为守护进程并不与终端相结合
                    它们或者是无控制终端的会话首进程
                    或者是孤儿进程组的成员
                        所以守护进程并不期望接收SIGHUP
                            于是它们可以安全地重复使用它
```


13.7 客户进程-服务器进程模型
```
    守护进程常常用作服务器进程
        服务器是等待客户进程与其联系的一个进程
            客户进程向它提出某种类型的服务要求
```


13.8 小结
习题
第14章 高级I/O
14.1 引言
14.2 非阻塞I/O
14.3 记录锁
14.4 I/O多路转接
14.4.1 函数select和pselect
14.4.2 函数poll
14.5 异步I/O
14.5.1 System V异步I/O
14.5.2 BSD异步I/O
14.5.3 POSIX异步I/O
14.6 函数readv和writev
14.7 函数readn和writen
14.8 存储映射I/O
14.9 小结
第15章进程间通信429 
```
    进程之间相互通信的技术——IPC（InterPorcess Communication）
    UNIX系统IPC类型细分有以下9种：
        半双工管道
        FIFO
        全双工管道
        命名全双工管道
        消息队列
        信号量
        共享存储
        套接字
        STREAMS
    前7种IPC通常限于同一台主机的各个进程间的IPC
        最后两种IPC
            是仅有的两种支持不同主机上各个进程间IPC的类型

```

15.1 引言429 
15.2 管道430 
```
管道是UNIX系统IPC的最古老的形式，并且所有UNIX系统都提供此种通信机制。管道有下面两种局限性：
（1）历史上，它们是半双工的（即数据只能在一个方向上流动）。现在，某些系统提供全双工管道，但是为了最佳的可移植性，我们决不应预先假定系统使用此特性。
（2）它们只能在具有公共祖先的进程之间使用。通常，一个管道由一个进程创建，然后该进程调用fork，此后父、子进程之间就可应用该管道。
```
15.3函数popen和pclose436 
15.4 协同进程441 
当一个程序产生某个过滤程序的输入，同时又读取该过滤程序的输出时，则该过滤程序就成为协同进程（coprocess）。

15.5 FIFO445 
FIFO是一种文件类型
```
    FIFO有下面两种用途：
        （1）FIFO由shell命令使用以便将数据从一条管道线传送到另一条
            为此无需创建中间临时文件
        （2）FIFO用于客户进程-服务器进程应用程序中
            以在客户进程和服务器进程之间传送数据


实例：用FIFO复制输出流
管道只能用于进程间的线性连接，然而，因为FIFO具有名字，所以它可用于非线性连接。
实例：客户进程-服务器进程使用FIFO进行通信
```



15.6 XSIIPC448 
XSI IPC源自于系统V的IPC功能。
```
    有三种IPC我们称作XSI IPC
        即消息队列
        信号量以
        共享存储器

1、标识符和键

每个内核中的IPC结构（消息队列、信号量或共享存储段）都用一个非负整数的标识符（identifier）加以引用。例如，为了对一个消息队列发送或取消息，只需要知道其队列标识符。
与文件描述符不同，IPC标识符不是小的整数。当一个IPC结构被创建，以后又被删除时，与这种结构相关的标识符连续加1，直到达到一个整型数的最大正值，然后又回转到0.

标识符是IPC对象的内部名。为使多个合作进程能够在同一IPC对象上会合，需要提供一个外部名方案。为此使用了键（key），每个IPC对象都与一个键相关联，于是键就用作为该对象的外部名。

无论何时创建IPC结构（调用msgget、semget或shmget），都应指定一个键，键的数据类型是基本系统数据类型key_t，通常在头文件<sys/types.h>中被定义为长整型。键由内核变换成标识符。
```


15.6.1标识符和键448 
15.6.2权限结构449 
15.6.3结构限制450 
15.6.4优点和缺点450 
XSI IPC的主要问题是：IPC结构是在系统范围内起作用的，没有访问计数。
XSI IPC的另一个问题是：这些IPC结构在文件系统中没有名字。


15.7 消息队列451 
消息队列是消息的链接表，存放在内核中并由消息队列标识符标识。在本节中，我们把消息队列简称为队列（queue），其标识符为队列ID（queue ID）。

msgget用于创建一个新队列或打开一个现存的队列。msgsnd将新消息添加到队列尾端。每个消息包含一个正长整型类型字段，一个非负长度以及实际数据字节（对应于长度），所有这些都在将消息添加到队列时，传送给msgsnd。msgrcv用于从队列中取消息。我们并不一定要以先进先出次序取消息，也可以按消息的类型字段取消息。

15.8 信号量455 
```
它是一个计数器，用于多进程对共享数据对象的访问。

为了获得共享资源，进程需要执行下列操作：
（1）测试控制该资源的信号量。
（2）若此信号量的值为正，则进程可以使用该资源。进程将信号量值减1，表示它使用了一个资源单位。
（3）若此信号量的值为0，则进程进入休眠状态，直至信号量值大于0.进程被唤醒后，它返回至第（1）步。

当进程不再使用由一个信号量控制的共享资源时，该信号量值增1。如果有进程正在休眠等待此信号量，则唤醒它们。
为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。
常用的信号量形式被称为二元信号量或双态信号量（binary semaphore）。它控制单个资源，初始值为1。但是一般而言，信号量的初值可以是
```
15.9 共享存储459 
15.10 POSIX信号量465 
15.11 客户进程—服务器进程属性470 
15.11小结472 
习题472 
第16章网络IPC：套接字474 
16.1引言474 
```
    网络进程间通信（network IPC）：
        不同计算机（通过网络相连）上运行的进程相互通信的机制
    套接字网络IPC接口：
        进程能够使用该接口和其他进程通信
        通过该接口其他进程运行位置是透明的
            它们可以在同一台计算机上也可以在不同的计算机上
        实际上这正是套接字接口的目标之一：
            同样的接口既可以用于计算机间通信又可以用于计算机内通信
```

16.2套接字描述符474 
```
    套接字是通信端点的抽象
        与应用程序要使用文件描述符访问文件一样
        访问套接字也需要套接字描述符
        套接字描述符在UNIX系统是用文件描述符实现的
        事实上许多处理文件描述符的函数（如read和write）都可以处理套接字描述符
```

16.3寻址477 
```
    进程的标识有两个部分：
        计算机的网络地址可以帮助标识网络上想与之通信的计算机
        而服务可以帮助标识计算机上特定的进程
    １、字节序
        运行在同一台计算机上的进程相互通信时
            一般不用考虑字节的顺序（字节序）
                字节序是一个处理器架构特性
                    用于指示像整数这样的大数据类型的内部字节顺序
        不管字节如何排序，数字最高位总是在左边，最低位总是在右边
    2、地址格式
        地址标识了特定通信域中的套接字端点
        地址格式与特定的通信域相关
        为使不同格式地址能够被传入到套接字函数
            地址被强制转换成通用的地址结构sockaddr表示
    3、地址查询
        理想情况下应用程序不需要了解套接字地址的内部结构
        如果应用程序只是简单地传递类似于sockaddr结构的套接字地址
            并且不依赖于任何协议相关的特性
                那么可以与提供相同服务的许多不同协议协作
    4、将套接字与地址绑定
        与客户端的套接字关联的地址没有太大的意义
            可以让系统选一个默认的地址
        对于服务器需要给一个接收客户端请求的套接字绑定一个众所周知的地址
            客户端应有一种方法来发现用以连接服务器的地址
                最简单的方法就是为服务器保留一个地址并且在/etc/services或者某个名字服务（name service）中注册
```




16.3.1字节序477 
16.3.2地址格式478 
16.3.3 地址查询480 
16.3.4 将套接字与地址关联486 
16.4建立连接487 
16.5数据传输491 
16.6套接字选项502 
16.7带外数据504 
16.8非阻塞和异步I/O505 
16.9小结506 
习题506 
第17章高级进程间通信507 
17.1 引言507 
17.2 UNIX域套接字507 
17.3 唯一连接512 
17.4 传送文件描述符518 
17.5 open服务器进程第1版527 
17.6 open服务器进程第2版533 
17.7小结542 
习题542 
第18章终端I/O544 
18.1引言544 
18.2综述544 
18.3特殊输入字符549 
18.4获得和设置终端属性553 
18.5终端选项标志554 
18.6stty命令560 
18.7波特率函数560 
18.8行控制函数561 
18.9终端标识562 
18.10规范模式567 
18.11非规范模式570 
18.12终端窗口大小576 
18.13termcap、terminfo和curses578 
18.14小结578 
习题579 
第19章伪终端580 
19.1引言580 
19.2概述580 
19.3打开伪终端设备585 
19.4函数pty_fork588 
19.5pty程序590 
19.6使用pty程序595 
19.7高级特性600 
19.8小结601 
习题601 
第20章数据库函数库603 
20.1 引言603 
20.2 历史603 
20.3函数库604 
20.4 实现概述605 
20.5集中式或非集中式608 
20.6并发610 
20.7构造函数库610 
20.8源代码611 
20.9性能635 
20.10小结639 
习题639 
第21章与网络打印机通信640 
21.1引言640 
21.2网络打印协议640 
21.3超文本传输协议HTTP642 
21.4打印假脱机技术643 
21.5源代码644 
21.6小结684 
习题684 
附录A函数原型685 
附录A函数原型附录B其他源代码721 
附录C部分习题答案730 
附录参考书目730 
索引770


