`源自开源--源码分析笔记`

Docker命令的flag参数解析
```
Docker请求中的参数分为两类：
第一类 命令行参数--flag参数即docker程序运行时所需提供的参数，如: -D、--daemon=true、--daemon=false等；
第二类 docker发送给Docker Server的实际请求参数，如：ps、pull NAME等。
```
配置Docker Daemon
```
配置信息服务于Docker Daemon的运行，并在Docker Daemon启动初期就初始化完毕。配置信息的主要功能是：供用户自由配置Docker的可选功能，使得Docker的运行更贴近用户所期待的运行场景。

配置信息的处理包含4部分：

配置Docker容器的MTU；
检测网桥配置信息；
查验容器通信配置；
处理PID文件配置。
```
```
主要是创建Docker Daemon运行中所在的工作目录。实现过程中，通过config中的Root属性来完成。在默认配置文件中，Root属性的值为”/var/lib/docker”。

在配置工作路径的代码实现中，步骤如下： 
(1) 使用规范路径创建一个TempDir，路径名为tmp； 
(2) 通过tmp，创建一个指向tmp的文件符号连接realTmp； 
(3) 使用realTemp的值，创建并赋值给环境变量TMPDIR； 
(4) 处理config的属性EnableSelinuxSupport； 
(5) 将realRoot重新赋值于config.Root，并创建Docker Daemon的工作根目录
```
创建容器仓库目录
```
Docker Daemon在创建Docker容器之后，需要将容器放置于某个仓库目录下，统一管理。
而这个目录即为daemonRepo，值为：/var/lib/docker/containers
```
创建Docker Daemon网络环境
```
在创建网络时，Docker Daemon是通过运行名为”init_networkdriver”的job来完成的。代码如下：

    if !config.DisableNetwork {

        job := eng.Job("init_networkdriver")
        
        job.SetenvBool("EnableIptables", config.EnableIptables)

        job.SetenvBool("InterContainerCommunication", config.InterContainerCommunication)

        job.SetenvBool("EnableIpForward", config.EnableIpForward)

        job.Setenv("BridgeIface", config.BridgeIface)

        job.Setenv("BridgeIP", config.BridgeIP)

        job.Setenv("DefaultBindingIP", config.DefaultIp.String())

        if err := job.Run(); err != nil {
            return nil, err
        }
    }

```
创建Docker网络设备
```
在InitDriver函数运行过程中，
首先 使用job的环境变量初始化内部变量；
然后 根据目前网络环境
  判断 是否创建docker0网桥
    若Docker专属网桥已存在
      则继续往下执行
    否则的话，
      创建docker0网桥
```
启用iptables功能并配置
```
创建完网桥之后，Docker Daemon为容器以及host主机配置iptables，
包括为container之间所需要的link操作提供支持，为host主机上所有的对外对内流量制定传输规则等。

    // Configure iptables for link support
    if enableIPTables {
        if err := setupIPTables(addr, icc); err != nil {

            return job.Error(err)
        }
    }
setupIPtables的调用过程中，addr地址为Docker网桥的网络地址，
  icc 为true
    即为允许Docker容器间互相访问
```
设置iptables规则
```
假设网桥设备名为docker0，网桥网络地址为docker0_ip,设置iptables规则，操作步骤如下： 
(1) 使用iptables工具开启新建网桥的NAT功能，使用命令如下：

    iptables -I POSTROUTING -t nat -s docker0_ip ! -o docker0 -j MASQUERADE

(2) 通过icc参数
        决定 是否允许container间通信
            并制定相应iptables的Forward链
            
    Container之间通信，说明数据包从container内发出后，经过docker0
    并且还需要在docker0处发往docker0，最终转向指定的container。 
    
    换言之，从docker0出来的数据包，如果需要继续发往docker0，
        则说明 是container的通信数据包。命令使用如下：

    iptables -I FORWARD -i docker0 -o docker0 -j ACCEPT

(3) 允许接受从container发出，且不是发往其他container数据包。
    换言之，允许所有从docker0发出
        且不是继续发向docker0的数据包，使用命令如下：

    iptables -I FORWARD -i docker0 ! -o docker0 -j ACCEPT

(4) 对于发往docker0，并且属于已经建立的连接的数据包，Docker无条件接受这些数据包，使用命令如下：

    iptables -I FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT 
```
启用系统数据包转发功能
```
echo >> 1 /proc/sys/net/ipv4/ip_forward # 开启转发
在Linux系统上，数据包转发功能是被默认禁止的。数据包转发，就是当host主机存在多块网卡的时，如果其中一块网卡接收到数据包，并需要将其转发给另外的网卡。
```
创建DOCKER链
```
在网桥设备上创建一条名为DOCKER的链，该链的作用是在创建Docker container并设置端口映射时使用。
```
注册Handler至Engine
```
在创建完网桥，并配置完基本的iptables规则之后，Docker Daemon在网络方面还在Engine中注册了4个Handler，这些Handler的名称与作用如下： 
```
* * allocate_interface：为Docker container分配一个专属网卡
* * realease_interface：释放网卡资源
* * allocate_port：为Docker container分配一个端口
* * link：实现Docker container间的link操作
* 创建graphdb并初始化
``` 
Graphdb是一个构建在SQLite之上的图形数据库，通常用来记录节点命名以及节点之间的关联。
Docker Daemon使用graphdb来记录镜像之间的关联。
```
创建execdriver
```
Execdriver是Docker中用来执行Docker container任务的驱动
在创建execdriver的时候，需要4部分的信息，以下简要介绍这4部分信息：
```
- - config.ExecDriver:Docker运行时中指定使用的exec驱动类别，在默认配置文件中默认使用”native”,也可以将这个值改为”lxc”，则使用lxc接口执行Docker container内部的操作
- - config.Root:Docker运行时的root路径，默认配置文件中为”/var/lib/docker”
- - sysInitPath:系统上存放dockerinit文件的路径，一般为”/var/lib/docker/init/dockerinit-1.2.0”
- - sysInfo:系统功能信息，包括：容器的内存限制功能，交换区内存限制功能，数据转发功能，以及AppArmor安全功能
创建daemon对象
```
在经过以上诸多设置以及创建对象之后，整合众多内容，创建最终的Daemon对象实例daemon，实现代码如下：

    daemon := &Daemon{

        repository:     daemonRepo,

        containers:     &contStore{s: make(map[string]*Container)},

        graph:          g,

        repositories:   repositories,

        idIndex:        truncindex.NewTruncIndex([]string{}),

        sysInfo:        sysInfo,

        volumes:        volumes,

        config:         config,

        containerGraph: graph,

        driver:         driver,

        sysInitPath:    sysInitPath,

        execDriver:     ed,

        eng:            eng,

    }
```
检测DNS配置
```
Docker Daemon使用daemon.checkLocaldns()检测Docker运行环境中DNS的配置
采用默认外在DNS服务器，为8.8.8.8，8.8.4.4，并将其赋值给config文件中的Dns属性。
```
启动时加载已有Docker containers
```
当Docker Daemon启动时，会去查看在daemon.repository，也就是在/var/lib/docker/containers中的内容。
若有存在Docker container的话，则让Docker Daemon加载这部分运行着的容器，将容器信息收集，并做相应的维护。
```
---

Docker Server
```
作为Docker Daemon架构中请求的入口，接管了所有Docker Daemon对外的通信。
接受用户通过Docker Client发送的请求，并按照相应的路由规则实现路由分发。 

```
ListenAndServe的实现可以分为以下4个部分
```
创建router路由实例；
创建listener监听实例；
创建http.Server；
启动API服务。
```
---
Docker网络桥接
```
 | Docker Container|| Docker Container|| Docker Container |
 |     eth0        ||      eth0       ||      eth0        |
        |                   |                  |
     | veth |             |veth|             |veth|
     |           docker0(birdge)                  |
                            |  ipv4 ip_forward
                      | host eth0 |
     
      
```
Docker会使用到的5个flag参数
* EnableIptables：`确保Docker对于宿主机上的iptables规则拥有添加权限；`
* EnableIpForward：`确保net.ipv4.ip_forward可以使用，使得多网络接口设备模式下，数据报可以在网络设备之间转发；`
* BridgeIP：`在Docker Daemon启动过程中，为网络环境中的网桥配置CIDR网络地址；`
* BridgeIface：`为Docker网络环境指定具体的通信网桥，若BridgeIface的值为”none”，则说明不需要为Docker Container创建网桥服务，关闭Docker Container的网络能力；`
* InterContainerCommunication：`确保Docker容器之间可以完成通信。`
```

---
